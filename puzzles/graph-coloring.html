<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Coloring - CS Puzzles</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        .graph-container {
            background-color: var(--card-background);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: var(--box-shadow);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .graph-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
        }

        canvas {
            background-color: var(--background-color);
            border-radius: var(--border-radius);
            width: 100%;
            height: 400px;
            touch-action: none;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1.5rem 0;
            justify-content: center;
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin: 1rem 0;
            padding: 1rem;
            background-color: var(--background-color);
            border-radius: var(--border-radius);
        }

        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: var(--transition);
            box-shadow: var(--box-shadow);
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: var(--secondary-color);
            transform: scale(1.1);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
            padding: 1rem;
            background-color: var(--background-color);
            border-radius: var(--border-radius);
        }

        .stat-item {
            text-align: center;
            padding: 1rem;
            background-color: var(--card-background);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        .stat-item h3 {
            color: var(--primary-color);
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .stat-item p {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--secondary-color);
        }

        .solution-info {
            background-color: var(--card-background);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-top: 1.5rem;
            box-shadow: var(--box-shadow);
            display: none;
        }

        .solution-info h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.4rem;
        }

        .solution-info p {
            color: var(--text-color);
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }

        .btn {
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            min-width: 150px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn i {
            font-size: 1.2rem;
        }

        @media (max-width: 768px) {
            .graph-container {
                padding: 1rem;
            }

            canvas {
                height: 300px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .btn {
                width: 100%;
            }

            .color-palette {
                padding: 0.5rem;
            }

            .color-option {
                width: 35px;
                height: 35px;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .stat-item {
                padding: 0.8rem;
            }

            .stat-item h3 {
                font-size: 1.1rem;
            }

            .stat-item p {
                font-size: 1.3rem;
            }
        }

        @media (max-width: 480px) {
            canvas {
                height: 250px;
            }

            .color-option {
                width: 30px;
                height: 30px;
            }

            .solution-info {
                padding: 1rem;
            }

            .solution-info h3 {
                font-size: 1.2rem;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) {
            .color-option:hover {
                transform: none;
            }

            .color-option.selected {
                transform: scale(1.1);
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Graph Coloring Problem</h1>
        <nav>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../index.html#puzzles">Puzzles</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <div class="graph-container">
            <h2>Graph Coloring Challenge</h2>
            <p>Color the graph so that no adjacent vertices have the same color. Try to use the minimum number of colors possible!</p>
            
            <div class="stats">
                <div class="stat-item">
                    <div>Colors Used</div>
                    <div class="stat-value" id="colorCount">0</div>
                </div>
                <div class="stat-item">
                    <div>Vertices</div>
                    <div class="stat-value" id="vertexCount">0</div>
                </div>
                <div class="stat-item">
                    <div>Edges</div>
                    <div class="stat-value" id="edgeCount">0</div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="graphCanvas"></canvas>
            </div>

            <div class="color-palette" id="colorPalette"></div>

            <div class="controls">
                <button class="btn" onclick="resetGraph()">New Graph</button>
                <button class="btn" onclick="checkSolution()">Check Solution</button>
                <button class="btn" onclick="showOptimalSolution()">Show Optimal Solution</button>
            </div>

            <div class="win-message" id="winMessage">
                Congratulations! You found a valid coloring!
            </div>

            <div class="solution-info" id="solutionInfo" style="display: none; margin-top: 1rem; padding: 1rem; background-color: #e9ecef; border-radius: 4px;">
                <h3>Optimal Solution Information</h3>
                <p>The graph has been colored using a greedy algorithm. The chromatic number (minimum number of colors needed) is: <span id="chromaticNumber">0</span></p>
                <p>This solution guarantees that no adjacent vertices share the same color.</p>
            </div>
        </div>
    </main>

    <footer>
        <p>&copy; 2024 CS Puzzles & Games. All rights reserved.</p>
    </footer>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let selectedColor = null;
        let isDragging = false;
        let dragNode = null;
        let colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f1c40f',
            '#9b59b6', '#e67e22', '#1abc9c', '#34495e'
        ];

        function initializeCanvas() {
            // Set canvas size
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = 400;
                drawGraph();
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Initialize color palette
            const palette = document.getElementById('colorPalette');
            colors.forEach((color, index) => {
                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = color;
                colorOption.addEventListener('click', () => selectColor(index));
                palette.appendChild(colorOption);
            });

            // Generate random graph
            generateRandomGraph();
        }

        function generateRandomGraph() {
            nodes = [];
            edges = [];
            const numNodes = Math.floor(Math.random() * 5) + 5; // 5-10 nodes
            const numEdges = Math.floor(Math.random() * (numNodes * 2)) + numNodes; // At least numNodes edges

            // Create nodes
            for (let i = 0; i < numNodes; i++) {
                nodes.push({
                    id: i,
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    color: null
                });
            }

            // Create edges
            for (let i = 0; i < numEdges; i++) {
                const node1 = Math.floor(Math.random() * numNodes);
                let node2;
                do {
                    node2 = Math.floor(Math.random() * numNodes);
                } while (node2 === node1 || edgeExists(node1, node2));
                
                edges.push({ from: node1, to: node2 });
            }

            updateStats();
            drawGraph();
        }

        function edgeExists(node1, node2) {
            return edges.some(edge => 
                (edge.from === node1 && edge.to === node2) ||
                (edge.from === node2 && edge.to === node1)
            );
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            edges.forEach(edge => {
                const from = nodes[edge.from];
                const to = nodes[edge.to];
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = node.color || '#3498db';
                ctx.fill();
                ctx.strokeStyle = selectedNode === node ? '#2c3e50' : '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw node label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id + 1, node.x, node.y);
            });
        }

        function selectColor(index) {
            selectedColor = colors[index];
            document.querySelectorAll('.color-option').forEach((option, i) => {
                option.classList.toggle('selected', i === index);
            });
        }

        function getNodeAtPosition(x, y) {
            return nodes.find(node => {
                const dx = node.x - x;
                const dy = node.y - y;
                return Math.sqrt(dx * dx + dy * dy) <= 20;
            });
        }

        // Event Listeners
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const node = getNodeAtPosition(x, y);
            if (node) {
                if (selectedColor) {
                    node.color = selectedColor;
                    drawGraph();
                    updateStats();
                }
                selectedNode = node;
                isDragging = true;
                dragNode = node;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && dragNode) {
                const rect = canvas.getBoundingClientRect();
                dragNode.x = e.clientX - rect.left;
                dragNode.y = e.clientY - rect.top;
                drawGraph();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            dragNode = null;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            dragNode = null;
        });

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const node = getNodeAtPosition(x, y);
            if (node && selectedColor) {
                node.color = selectedColor;
                drawGraph();
                updateStats();
            }
        });

        function updateStats() {
            const usedColors = new Set(nodes.map(node => node.color).filter(Boolean));
            document.getElementById('colorCount').textContent = usedColors.size;
            document.getElementById('vertexCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = edges.length;
        }

        function checkSolution() {
            // Check if all nodes are colored
            if (nodes.some(node => !node.color)) {
                alert('Please color all vertices!');
                return;
            }

            // Check if any adjacent vertices have the same color
            const hasConflict = edges.some(edge => {
                const from = nodes[edge.from];
                const to = nodes[edge.to];
                return from.color === to.color;
            });

            if (hasConflict) {
                alert('Adjacent vertices cannot have the same color!');
            } else {
                document.getElementById('winMessage').style.display = 'block';
            }
        }

        function resetGraph() {
            nodes.forEach(node => node.color = null);
            document.getElementById('winMessage').style.display = 'none';
            document.getElementById('solutionInfo').style.display = 'none';
            generateRandomGraph();
        }

        function showOptimalSolution() {
            // Reset current coloring
            nodes.forEach(node => node.color = null);
            
            // Create adjacency list
            const adjacencyList = nodes.map(() => []);
            edges.forEach(edge => {
                adjacencyList[edge.from].push(edge.to);
                adjacencyList[edge.to].push(edge.from);
            });

            // Sort nodes by degree (descending)
            const nodeDegrees = nodes.map((_, i) => ({
                index: i,
                degree: adjacencyList[i].length
            }));
            nodeDegrees.sort((a, b) => b.degree - a.degree);

            // Greedy coloring algorithm
            const usedColors = new Set();
            nodeDegrees.forEach(({ index }) => {
                const node = nodes[index];
                const adjacentColors = new Set();
                
                // Get colors of adjacent nodes
                adjacencyList[index].forEach(adjIndex => {
                    if (nodes[adjIndex].color) {
                        adjacentColors.add(nodes[adjIndex].color);
                    }
                });

                // Find the first available color
                let colorIndex = 0;
                while (adjacentColors.has(colors[colorIndex])) {
                    colorIndex++;
                }

                // Assign color to node
                node.color = colors[colorIndex];
                usedColors.add(colors[colorIndex]);
            });

            // Update display
            drawGraph();
            updateStats();
            
            // Show solution info
            document.getElementById('chromaticNumber').textContent = usedColors.size;
            document.getElementById('solutionInfo').style.display = 'block';
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', initializeCanvas);
    </script>
</body>
</html> 